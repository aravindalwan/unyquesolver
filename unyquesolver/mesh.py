'''Mesh generator for physical domains on which PDEs are solved'''

__copyright__ = 'Copyright (C) 2012 Aravind Alwan'

__license__ = '''
This file is part of UnyQuE.

UnyQuE is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

UnyQuE is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

For a copy of the GNU General Public License, please see
<http://www.gnu.org/licenses/>.
'''

import math
import itertools as it
from collections import defaultdict
import operator
from meshpy.triangle import MeshInfo, build
import unyque._internals as internals

class PhysicalDomain(object):
    '''Object that encapsulates the physical domain on which a PDE is solved
    '''

    def __init__(self, vertices, boundaries, boundary_markers, regions,
                 svboundary = None, options = None):
        '''Initialize geometry object using vertices, boundaries and regions.

        Arguments:
        vertices -- list of vertex co-ordinates given as (x,y) tuples
        boundaries -- list of tuples specifying end-points of boundaries
        boundary_markers -- list of boundary markers (0 = no marker)
        regions -- list of regions, where each region is a list of the form
                   [x-coord, y-coord, reg. marker, reg. attribute]
        svboundary -- Marker corresponding to the boundary that is denoted as
                      spatially varying (None if all boundaries are fixed)
        options -- Dictionary of key/value pairs specifying modifications to the
                   default set of options passed to MeshPy's build function
        '''
        self.vertices = vertices
        self.boundaries = boundaries
        self.boundary_markers = boundary_markers
        self.regions = regions
        self.spatially_varying_boundary = svboundary
        self.options = dict({
                'verbose': False, 'refinement_func': None, 'attributes': False,
                'volume_constraints': False, 'max_volume': None,
                'allow_boundary_steiner': True, 'allow_volume_steiner': True,
                'quality_meshing': True, 'generate_edges': None,
                'generate_faces': False, 'min_angle': None, 'mesh_order': None})

        if options:
            for key in options:
                try:
                    self.options[key] = options[key]
                except:
                    raise ValueError('Invalid key: {k}'.format(k = key))

        # Build mesh by calling Triangle using the MeshPy interface
        self.info = MeshInfo()
        self.info.set_points(self.vertices)
        self.info.set_facets(self.boundaries, self.boundary_markers)
        self.info.regions.resize(len(self.regions))
        for i, region in enumerate(self.regions):
            self.info.regions[i] = region
        self.mesh = build(self.info, **self.options)

        # Process mesh to make it compatible with the FE solver
        self._process_mesh()

    def _process_mesh(self):
        '''Generate processed mesh data using the mesh generated by Triangle.
        This creates the Point, Edge and Element obejcts that the solver needs.
        Since the FE solver expects that node, edge and element indices start
        with 1, while Triangle assumes that everything is 0-indexed, all indices
        are incremented by 1 when creating Point, Edge and Element objects.
        '''

        # Create list of node objects. All numbering starts with 1
        self.nodes = [internals.Point(i + 1, marker, *pt) for i, (pt, marker) in
                      enumerate(it.izip(
                    self.mesh.points, self.mesh.point_markers))]

        # Create lists of elements and edges
        self.elements, self.edges = self._process_elements_and_edges()

    def _process_elements_and_edges(self):

        node2edge = self._process_edges()

        elements = list()
        edge_dict = dict()
        for elem_id, elem in enumerate(self.mesh.elements):

            # Change order of nodes 4, 5 and 6 for each element because the FEM
            # routine assumes a different ordering convention from what is used
            # by Triangle. In this convention, node 4 lies between 1 & 2, node
            # 5 between 2 & 3 and node 6 between 3 & 1. Compare this with
            # http://www.cs.cmu.edu/~quake/triangle.highorder.html
            elem[3], elem[4], elem[5] = elem[5], elem[3], elem[4]

            # Store element. All numbering starts with 1
            elements.append(internals.Element(
                    elem_id + 1, int(self.mesh.element_attributes[elem_id]),
                    *map(lambda x: x + 1, elem)))

            for edge_type in range(3):

                node1 = elem[ edge_type       ]
                node2 = elem[(edge_type + 1)%3]
                node3 = elem[(edge_type + 2)%3] # Node opp to edge
                node_intermediate = elem[edge_type + 3]

                edge_id = self._find_edge(node2edge, node1, node2)
                edge = self.mesh.faces[edge_id]

                if (self.mesh.face_markers[edge_id] > 0): # on the boundary
                    normal = self._get_normal(node1, node2, node3)
                else:
                    normal = 0.0

                if edge_id not in edge_dict: # Store first occurrence
                    # Store attributes of edge. All numbering starts with 1
                    edge_dict[edge_id] = (edge_id + 1, elem_id + 1, edge_type,
                                          self.mesh.face_markers[edge_id], normal,
                                          node1 + 1, node2 + 1,
                                          node_intermediate + 1)

        # Sort edges according to the edge ID
        edge_list = sorted(edge_dict.values(), key=lambda edge: edge[0])

        edges = [internals.Edge(*edge) for edge in edge_list]

        return (elements, edges)

    def _process_edges(self):

        # Create a dictionary mapping each node to the edges that it belongs to
        node_to_edge = defaultdict(list)
        for i, edge in enumerate(self.mesh.faces):
            node_to_edge[edge[0]].append(i)
            node_to_edge[edge[1]].append(i)

        return node_to_edge

    def _find_edge(self, node_to_edge, n1, n2):

        # Return intersection between the lists of edges that n1 and n2 belong
        # to, knowing that there can only be one common edge
        # http://dev.ionous.net/2009/01/python-find-item-in-list.html
        return (val for val in node_to_edge[n1]
                if val in node_to_edge[n2]).next()

    def _get_normal(self, n1, n2, n3):

        node1 = self.mesh.points[n1]
        node2 = self.mesh.points[n2]
        node3 = self.mesh.points[n3]

        # Vector along edge
        edge_vec = (node2[0] - node1[0], node2[1] - node1[1])
        mag_sq = edge_vec[0]**2 + edge_vec[1]**2

        # Vector to interior node
        int_vec = (node3[0] - node1[0], node3[1] - node1[1])

        # Scalar product of these two vectors
        dot_prod = edge_vec[0]*int_vec[0] + edge_vec[1]*int_vec[1]

        # Vector in the direction of the outward normal
        outward_normal = (edge_vec[0]*dot_prod/mag_sq - int_vec[0],
                          edge_vec[1]*dot_prod/mag_sq - int_vec[1] )

        # Return angle in radians that outward normal makes with x-axis
        return math.atan2(outward_normal[1], outward_normal[0])

    def move_boundary(self, displace):
        '''Move boundary previously marked as spatially varying, according
        to the given displacement function. The function should take a single
        argument specifying the position along the boundary and return the
        displacement normal to the boundary at that point. The position is
        calculated in the local co-ordinate system such that the positive x-axis
        lies along the boundary and the outward normal vector is the positive
        y-axis. The boundary is assumed to be a straight line and uniquely
        specified by the spatially_varying_boundary attribute.
        '''

        # Generate the mesh corresponding to the original domain parameters
        self.info.set_points(self.vertices)
        self.info.set_facets(self.boundaries, self.boundary_markers)
        self.mesh = build(self.info, **self.options)
        self._process_mesh()

        # Loop over original set of boundaries
        boundaries = list() # New set of boundaries
        boundary_markers = list() # Corresponding boundary markers
        end_points = None # End-points of the boundary that is spatially varying
        normal = None # Angle w.r.t x-axis of the normal to this boundary
        for boundary, marker in it.izip(self.boundaries, self.boundary_markers):

            if marker == self.spatially_varying_boundary:

                # Store end-points of the spatially-varying boundary
                end_points = [self.vertices[i] for i in boundary]

                # Get the normal for this boundary, which is equal to the normal
                # for any edge lying on this boundary in the original mesh
                normal = (self.edges[i].normal
                          for i, mark in enumerate(self.mesh.face_markers)
                          if mark == self.spatially_varying_boundary).next()

                # Gather all boundary edges with this marker in original mesh
                for edge in (self.mesh.facets[i] for i, mark in
                                enumerate(self.mesh.facet_markers)
                                if mark == self.spatially_varying_boundary):
                    boundaries.append(edge)
                    boundary_markers.append(marker)

            else:
                boundaries.append(boundary)
                boundary_markers.append(marker)

        # Loop over new set of boundaries and map old vertex indices to new ones
        counter = 0
        vertex_map = dict()
        displaced_vertices = set()
        for i, boundary in enumerate(boundaries[:]):

            for vertex in boundary:

                # Add vertex to vertex_map if it is not already there
                if vertex not in vertex_map:
                    vertex_map[vertex] = counter
                    counter = counter + 1

                # If boundary is spatially varying, mark vertex for displacement
                if boundary_markers[i] == self.spatially_varying_boundary:
                    displaced_vertices.add(vertex_map[vertex])

            boundaries[i] = (vertex_map[boundary[0]], vertex_map[boundary[1]])

        # Get a list of key-value tuples in vertex_map sorted by value, which is
        # the second element of the tuple. This sorting gives the order in which
        # the vertices were added.
        # stackoverflow.com/questions/613183/python-sort-a-dictionary-by-value
        items = sorted(vertex_map.iteritems(), key = operator.itemgetter(1))

        # Generate a list of new vertices using the first element of the tuples
        # in items, since this corresponds to the index in the existing mesh
        vertices = [self.mesh.points[item[0]] for item in items]

        if self.spatially_varying_boundary:

            # Determine reference point for the varying boundary by using the
            # cross-product of the vector along the boundary with the normal
            # to determine the orientation
            start = end_points[0]
            stop = end_points[1]
            boundary_vector = [stop[0] - start[0], stop[1] - start[1]]
            ref_point = start if (
                boundary_vector[0]*math.sin(normal) -
                boundary_vector[1]*math.cos(normal) > 0) else stop

            # Apply displacement function on vertices that need to be displaced
            for i in displaced_vertices:
                vertex = vertices[i]
                displacement = displace(math.sqrt((vertex[0]-ref_point[0])**2 +
                                                  (vertex[1]-ref_point[1])**2))
                vertices[i] = [vertex[0] + displacement*math.cos(normal),
                               vertex[1] + displacement*math.sin(normal)]

        # Generate mesh corresponding to the new domain parameters
        self.info.set_points(vertices)
        self.info.set_facets(boundaries, boundary_markers)
        self.mesh = build(self.info, **self.options)

        # Process mesh to make it compatible with the FE solver
        self._process_mesh()
